
" vim-sublime - A minimal Sublime Text - like vim experience bundle
"               http://github.com/grigio/vim-sublime
" Best view with a 256 color terminal and Powerline fonts
" Updated by Dorian Neto (https://github.com/dorianneto)"

" Enable CTRL
"
"

call plug#begin('~/.vim/plugged')
" ------Plugins-------
"Plug 'dense-analysis/ale'
Plug 'Erichain/vim-monokai-pro'
Plug 'RRethy/vim-illuminate'
Plug 'airblade/vim-rooter'
Plug 'beyondwords/vim-twig'
Plug 'editorconfig/editorconfig-vim'
Plug 'fatih/vim-go', {'do': ':GoUpdateBinaries'}
Plug 'junegunn/fzf', {'do': { -> fzf#install() }}
Plug 'junegunn/fzf.vim'
Plug 'kyazdani42/nvim-web-devicons'
Plug 'mhinz/vim-signify'
Plug 'mhinz/vim-startify'
Plug 'milch/vim-fastlane'
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}  " We recommend updating the parsers on update
Plug 'ojroques/vim-oscyank'
Plug 'patstockwell/vim-monokai-tasty'
Plug 'phanviet/vim-monokai-pro'
Plug 'rust-lang/rust.vim'
Plug 'sheerun/vim-polyglot'
Plug 'terryma/vim-multiple-cursors'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-surround'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'vim-scripts/auto-pairs-gentle'
Plug 'voldikss/vim-floaterm'
Plug 'tpope/vim-fugitive'
Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
" Plug 'nvim-telescope/telescope.nvim'
Plug 'tpope/vim-commentary'

call plug#end()


let $NVIM_TUI_ENABLE_TRUE_COLOR=1


colorscheme monokai_pro 
filetype off
let &t_ut=''
set autoindent
set autoread
set backspace=indent,eol,start
set backupdir^=$HOME/tmp/hjvim
set belloff=all
set clipboard=unnamed
set cmdheight=2
set completeopt-=preview
set cursorline
set directory^=$HOME/tmp/hjvim
set encoding=utf-8  " The encoding displayed.
set fileencoding=utf-8  " The encoding written to file.
set fileformats=unix,dos,mac
set foldlevel=2
set foldmethod=syntax
set foldnestmax=10
set guifont=Hack\ Nerd\ Font:h16
set hidden
set hlsearch
set ignorecase
set incsearch
set indentexpr=
set laststatus=2
set lazyredraw
set nobackup
set nocindent
set nocompatible
set nofoldenable
set nofsync
set nosmartindent
set noswapfile
set nowritebackup
set nrformats-=octal
set number
set re=1
set ruler
set shiftround
set shortmess+=c
set showcmd
set showmatch
set showmode
set showtabline=2
set signcolumn=yes
set smartcase
set tabstop=2 shiftwidth=2 expandtab shiftwidth=2
set termguicolors
set textwidth=0 
set ttimeout
set ttimeoutlen=50
set ttyfast
set updatetime=300
set wildmenu
set wrap!
set wrapmargin=0
set relativenumber
syntax on



" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif



" Auto complete styling

highlight BufferCurrentSign guifg=#90C966 
highlight BufferInactiveSign guifg=#83A598 
highlight BufferVisibleSign guifg=#73BA9F 
highlight ColorColumn guibg=#343B46
highlight Cursor guibg=#EBDBB2
highlight GitSignsChange guifg=#E5C07B
highlight Pmenu ctermbg=238 gui=bold
highlight Pmenu ctermfg=NONE ctermbg=236 cterm=NONE guifg=NONE guibg=#64666d gui=NONE
highlight iCursor guibg=#EBDBB2
highlight oCursor guibg=#E5C07B
set guicursor+=i-c:ver100-iCursor
set guicursor+=o:block-oCursor
set guicursor+=r:hor10-iCursor
set guicursor=n-v:block-Cursor








" AU GROUPS
"
" RELOAD config if VIMRC is changed


augroup myvimrc
    au!
    au BufWritePost init.vim,.vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif
augroup END


" make Esc happen without waiting for timeoutlen
augroup FastEscape
  autocmd!
  au InsertEnter * set timeoutlen=0
  au InsertLeave * set timeoutlen=1000
augroup END


" PLUGIN CONFIG
"

" TELESCOPE
"
" lua << EOF
" local actions = require('telescope.actions')
" require('telescope').setup{
"   defaults = {
"     mappings = {
"       i = {
"         ["<esc>"] = actions.close
"       },
"       n = {
"         ["<esc>"] = actions.close
"       }
 
"     }
"   }
" }
" EOF


" TREESITTER
lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "maintained", -- one of "all", "maintained" (parsers with maintainers), or a list of languages
  ignore_install = { "javascript" }, -- List of parsers to ignore installing
  highlight = {
    enable = true,              -- false will disable the whole extension
    disable = { },  -- list of language that will be disabled
  },
}
EOF


" AIRLINE
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = 'unique_tail'
let g:airline#extensions#tabline#left_sep = ''
let g:airline#extensions#tabline#right_sep = ''
let g:airline#extensions#tabline#left_alt_sep = ''
let g:airline#extensions#tabline#right_alt_sep = ''
let airline#extensions#tabline#show_buffers = 0
let g:airline_theme='powerlineish'

" ALE
let g:ale_linters = {
\   'javascript': ['eslint'],
\   'haml': ['hamllint'],
\   'php': ['phpcs'],
\   'go': ['gofmt'],
\   'rust': ['rls']
\}
let g:ale_fixers = {
\   'javascript': ['prettier', 'eslint', 'remove_trailing_lines', 'trim_whitespace'],
\   'javascript.jsx': ['prettier', 'eslint', 'remove_trailing_lines', 'trim_whitespace'],
\   'ruby': ['rubocop', 'remove_trailing_lines', 'trim_whitespace'],
\   'haml': ['hamllint', 'remove_trailing_lines', 'trim_whitespace'],
\   'php': ['php_cs_fixer', 'phpcbf'],
\   'rust': ['rustfmt'],
\   'go': ['gofmt'],
\   'sh': ['shmft', 'remove_trailing_lines', 'trim_whitespace'],
\   'c': ['clang-format', 'remove_trailing_lines', 'trim_whitespace'],
\}
let g:ale_set_highlights = 0
let g:ale_lint_on_text_changed = 0
let g:ale_lint_on_enter = 0
let g:ale_lint_on_save = 1


" FZF
let $FZF_DEFAULT_COMMAND = 'rg --files --no-ignore-vcs  --hiden -i '
let g:fzf_buffers_jump = 1
let g:fzf_action = {
  \ 'ctrl-t': 'tab drop',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit'}


" FUGITIVE
"
nmap <Leader>gs :G<CR>
nmap <Leader>gf :diffget //2
nmap <Leader>gh :diffget //3

" COC
"
" Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')

" Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')


" Make autocomplete more better
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"



" Add `:OR` command for organize imports of the current buffer.
command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

" Add (Neo)Vim's native statusline support.
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline.
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}



" Use `[c` and `]c` for navigate diagnostics
nmap <silent> [c <Plug>(coc-diagnostic-prev)
nmap <silent> ]c <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)


" COC END



" FUNCTIONS

function! TabCloseRight(bang)
    let cur=tabpagenr()
    while cur < tabpagenr('$')
        exe 'tabclose' . a:bang . ' ' . (cur + 1)
    endwhile
endfunction

function! TabCloseLeft(bang)
    while tabpagenr() > 1
        exe 'tabclose' . a:bang . ' 1'
    endwhile
endfunction

command! -bang Tabcloseright call TabCloseRight('<bang>')
command! -bang Tabcloseleft call TabCloseLeft('<bang>')

command -bang -nargs=? QFix call QFixToggle(<bang>0)
function! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction


" KEY MAPS
"
map \ :
let mapleader = ','


""" COMMENT UNCOMMENT


"""""""YANK TO SSH CLIPBOARD 
vnoremap <Leader>y  :OSCYank<CR>
nnoremap <Leader>Y  v$:OSCYank<CR>
nnoremap <Leader>yy V:OSCYank<CR>

inoremap <silent> <F24> <C-\><C-O>:silent doautocmd FocusLost %<CR>
inoremap <silent> <F25> <C-\><C-O>:silent doautocmd FocusGained %<CR>


" OPTION+F quickfix toggle
nmap <silent> <C-f> :QFix<CR>

" OPTION+SHIFT+F - Search in Project (RIPGREP)
map <C-S-F> :Rg<CR>

" Apple Keyboard Pasting with OPTION+v 
imap <C-v> <C-R>+
cmap <C-v> <C-R>+




" TIG status
nnoremap <Leader>ag :FloatermNew --name=git_status --title="Git-Status" tig status<CR>
tnoremap <Leader>ag <C-\><C-n>:FloatermKill git_status <CR>





noremap  <C-S> :update<CR>
vnoremap <C-S> <C-C>:update<CR>
inoremap <C-S> <Esc>:update<CR>


if maparg('<C-L>', 'n') ==# ''
  nnoremap <silent> <C-L> :nohlsearch<CR><C-L>
endif


"
" Basic shortcuts definitions
"  most in visual mode / selection (v or ⇧ v)
"

" indent / deindent after selecting the text with (⇧ v), (.) to repeat.
vnoremap <Tab> >
vnoremap <S-Tab> <
" Text wrap simpler, then type the open tag or ',"
vmap <C-w> S

nnoremap <C-z>  :undo<CR>
inoremap <C-z>  <Esc>:undo<CR>
nnoremap <C-y>  :redo<CR>
inoremap <C-y>  <Esc>:redo<CR>






" Mark ALL
nnoremap <C-A> <ESC>ggVG<CR>
inoremap <C-A> <ESC>ggVG<CR>



" OPTION+M Terminal
nnoremap <C-S-m> :FloatermToggle<CR>
inoremap <C-S-m> :FloatermToggle<CR>
tnoremap <C-S-m> <C-\><C-n>:FloatermToggle<CR>






" OPTION + e -> GoDef
nmap <silent> <C-e> <Plug>(coc-definition)
imap <silent> <C-e> <ESC><Plug>(coc-definition)





set synmaxcol=240

" OPTION+P / CTRL+P

nnoremap <C-p> :GitFiles <CR>
inoremap <C-p> <ESC>:GitFiles <CR>

let g:fzf_preview_window = ['down:40%']




" OPTION + LEFT/RIGHT - navigate TABS
nnoremap <C-Left>  :tabprevious<CR>
inoremap <C-Left>  <Esc>:tabprevious<CR>i
nnoremap <C-Right>  :tabnext<CR>
inoremap <C-Right>  <Esc>:tabnext<CR>i

" OPTION + t  -> new TAB
nnoremap <C-t>  :tabnew<CR>
inoremap <C-t>  <Esc>:tabnew<CR>i
" OPTION + w -> close tab
inoremap <D-w>  <Esc>:tabclose<CR>i

" lazy ':'

nnoremap <Leader>p :set paste<CR>
"nnoremap <Leader>f :ALEFix<CR>
nnoremap <Leader>o :set nopaste<CR>




" this machine config
if filereadable(expand("~/.vimrc.local"))
  source ~/.vimrc.local
endif






