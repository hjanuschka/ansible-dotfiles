let g:loaded_clipboard_provider='1'
let g:loaded_matchparen = '1'

call plug#begin('~/.vim/plugged')
" ------Plugins-------
Plug 'nelsyeung/twig.vim'
Plug 'ahmedkhalf/lsp-rooter.nvim'
Plug 'kdheepak/lazygit.nvim'
Plug 'fatih/vim-go', {'do': ':GoUpdateBinaries'}

Plug 'junegunn/fzf', {'do': { -> fzf#install() }}
Plug 'ibhagwan/fzf-lua', {'branch': 'main'}
Plug 'vijaymarupudi/nvim-fzf'
Plug 'nvim-tree/nvim-web-devicons'
Plug 'el-iot/buffer-tree'
Plug 'lewis6991/gitsigns.nvim'
Plug 'mhinz/vim-startify'
Plug 'nvim-tree/nvim-tree.lua'


Plug 'ncm2/float-preview.nvim'
Plug 'hrsh7th/cmp-nvim-lsp'
Plug 'hrsh7th/nvim-cmp'
Plug 'hrsh7th/cmp-buffer'
Plug 'ray-x/lsp_signature.nvim'
Plug 'onsails/lspkind-nvim'
Plug 'nvim-lua/lsp-status.nvim'
Plug 'folke/trouble.nvim'
Plug 'folke/lsp-colors.nvim'
Plug 'ellisonleao/gruvbox.nvim'
Plug 'L3MON4D3/LuaSnip', {'tag': 'v2.*', 'do': 'make install_jsregexp'} " Replace <CurrentMajor> by the latest released major (first number of latest release)

Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}  " We recommend updating the parsers on update
Plug 'ojroques/vim-oscyank'
Plug 'rust-lang/rust.vim'
Plug 'tpope/vim-eunuch'
Plug 'romainl/vim-qf'
Plug 'tpope/vim-surround'
Plug 'VonHeikemen/lsp-zero.nvim', {'branch': 'v3.x'}
Plug 'neovim/nvim-lspconfig'
Plug 'williamboman/mason.nvim'
Plug 'williamboman/mason-lspconfig.nvim'
Plug 'nvim-lualine/lualine.nvim'
Plug 'akinsho/nvim-bufferline.lua'
Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
Plug 'ThePrimeagen/harpoon'
Plug 'NTBBloodbath/rest.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'tpope/vim-commentary'
Plug 'RishabhRD/popfix'
Plug 'RishabhRD/nvim-cheat.sh'
Plug 'terryma/vim-multiple-cursors'

call plug#end()



let $NVIM_TUI_ENABLE_TRUE_COLOR=1


" Disable gopls in vim-go / it is in the native lsp
let g:go_gopls_enabled = 0

lua <<EOF
require("gruvbox").setup()

-- OR setup with some options
require("nvim-tree").setup({
  sort = {
    sorter = "case_sensitive",
  },
  view = {
    width = 30,
  },
  renderer = {
    group_empty = true,
  },
  filters = {
    dotfiles = true,
  },
})

EOF

let g:gruvbox_contrast_dark = 'hard'
if exists("+termguicolors")
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum]"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum]"
endif
set background=dark
colorscheme gruvbox 





"colorscheme monokai_pro 
filetype off
set autoindent
set autoread
set backspace=indent,eol,start
set backupdir^=$HOME/tmp/hjvim
set belloff=all
set clipboard=unnamedplus
set cmdheight=2
set completeopt-=preview
set cursorline
set directory^=$HOME/tmp/hjvim
set encoding=utf-8  " The encoding displayed.
set fileencoding=utf-8  " The encoding written to file.
set fileformats=unix,dos,mac
set foldlevel=2
set foldmethod=syntax
set foldnestmax=10
set guifont=Hack\ Nerd\ Font:h16
set hidden
set hlsearch
set ignorecase
set incsearch
set indentexpr=
set laststatus=2
set lazyredraw
set nobackup
set nocindent
set nocompatible
set nofoldenable
set nofsync
set nosmartindent
set noswapfile
set nowritebackup
set nrformats-=octal
set number
set re=1
set ruler
set shiftround
set shortmess+=c
set showcmd
set noshowmatch
set showmode
set showtabline=3
set signcolumn=auto:2
set smartcase
set tabstop=2 shiftwidth=2 expandtab shiftwidth=2
set termguicolors
set textwidth=0 
set ttimeout
set ttimeoutlen=50
set ttyfast
set updatetime=300
set wildmenu
set nowrap!
set wrapmargin=0
set relativenumber
syntax on


" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif



" Auto complete styling

highlight BufferCurrentSign guifg=#90C966 
highlight BufferInactiveSign guifg=#83A598 
highlight BufferVisibleSign guifg=#73BA9F 
highlight ColorColumn guibg=#343B46
highlight Cursor guibg=#EBDBB2
highlight iCursor guibg=#EBDBB2
highlight oCursor guibg=#E5C07B
set guicursor+=i-c:ver100-iCursor
set guicursor+=o:block-oCursor
set guicursor+=r:hor10-iCursor
set guicursor+=n-v:block-Cursor





augroup highlight_yank
    autocmd!
    au TextYankPost * silent! lua vim.highlight.on_yank { higroup='Visual', timeout=300 }
augroup END

" AU GROUPS

" HEX EDITOR for binary files
" vim -b : edit binary using xxd-format!
augroup Binary
  au!
  au BufReadPre  *.jpeg let &bin=1
  au BufReadPost *.jpeg if &bin | %!xxd
  au BufReadPost *.jpeg set ft=xxd | endif
  au BufWritePre *.jpeg if &bin | %!xxd -r
  au BufWritePre *.jpeg endif
  au BufWritePost *.jpeg if &bin | %!xxd
  au BufWritePost *.jpeg set nomod | endif
augroup END

" FORCE AUTOINDENT
autocmd BufReadPost * setlocal autoindent



augroup cursorline
  autocmd!
  autocmd WinEnter,BufEnter * setlocal cursorline 
  autocmd WinLeave,BufLeave * setlocal nocursorline 
augroup END

"
" RELOAD config if VIMRC is changed


" wrap long lines in quickfix
augroup quickfix
    autocmd!
    autocmd FileType qf setlocal wrap
augroup END

augroup myvimrc
    au!
    au BufWritePost init.vim,.vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif
augroup END


" make Esc happen without waiting for timeoutlen
augroup FastEscape
  autocmd!
  au InsertEnter * set timeoutlen=0
  au InsertLeave * set timeoutlen=1000
augroup END

lua <<EOF
require('gitsigns').setup({
  signs = {
    add          = {hl = 'GitSignsAdd'   , text = '+', numhl='GitSignsAddNr'   , linehl='GitSignsAddLn'},
    change       = {hl = 'GitSignsChange', text = '~', numhl='GitSignsChangeNr', linehl='GitSignsChangeLn'},
    delete       = {hl = 'GitSignsDelete', text = '-', numhl='GitSignsDeleteNr', linehl='GitSignsDeleteLn'},
    topdelete    = {hl = 'GitSignsDelete', text = '-', numhl='GitSignsDeleteNr', linehl='GitSignsDeleteLn'},
    changedelete = {hl = 'GitSignsChange', text = '~', numhl='GitSignsChangeNr', linehl='GitSignsChangeLn'},
  }
})
EOF



" DEV ICONS
"
lua <<EOF
require'nvim-web-devicons'.setup {
 -- your personnal icons can go here (to override)
 -- DevIcon will be appended to `name`
 override = {
  zsh = {
    icon = "",
    color = "#428850",
    name = "Zsh"
  }
 };
 default = true;
}
EOF


" LSP Colors
"
lua <<EOF

local lsp_zero = require('lsp-zero')

lsp_zero.on_attach(function(client, bufnr)
  -- see :help lsp-zero-keybindings
  -- to learn the available actions
  lsp_zero.default_keymaps({buffer = bufnr})
end)

-- to learn how to use mason.nvim with lsp-zero
-- read this: https://github.com/VonHeikemen/lsp-zero.nvim/blob/v3.x/doc/md/guides/integrate-with-mason-nvim.md
require('mason').setup({})
require('mason-lspconfig').setup({
  ensure_installed = {},
  handlers = {
    lsp_zero.default_setup,
  },
})

-- PHP
-- composer global require php-stubs/wordpress-globals php-stubs/wordpress-stubs php-stubs/woocommerce-stubs php-stubs/acf-pro-stubs wpsyntex/polylang-stubs php-stubs/genesis-stubs php-stubs/wp-cli-stubs
require("lspconfig").intelephense.setup {
 settings = {
        intelephense = {
            stubs = { 
                "bcmath",
                "bz2",
                "calendar",
                "Core",
                "curl",
                "zip",
                "zlib",
                "wordpress",
                "woocommerce",
                "acf-pro",
                "wordpress-globals",
                "wp-cli",
                "genesis",
                "polylang"
            }
      }
  }
}

local cmp = require('cmp')
local cmp_action = require('lsp-zero').cmp_action()
local cmp_format = require('lsp-zero').cmp_format()


cmp.setup({
 sources = {
    {name = 'nvim_lsp'},
    {name = 'buffer'},
  },
  --- (Optional) Show source name in completion menu
  formatting = cmp_format,
  mapping = cmp.mapping.preset.insert({
    -- `Enter` key to confirm completion
    ['<CR>'] = cmp.mapping.confirm({select = false}),
    -- Ctrl+Space to trigger completion menu
    ['<C-Space>'] = cmp.mapping.complete(),
    -- Scroll up and down in the completion documentation
    ['<C-u>'] = cmp.mapping.scroll_docs(-4),
    ['<C-d>'] = cmp.mapping.scroll_docs(4),
  })
})

require "lsp_signature".setup()


EOF


lua <<EOF
-- Lua
require("lsp-colors").setup({
  Error = "#db4b4b",
  Warning = "#e0af68",
  Information = "#0db9d7",
  Hint = "#10B981"
})
EOF


lua <<EOF
require('lspkind').init();
EOF



" BUFFERLINE
lua << EOF
require'bufferline'.setup{
  options = {
    separator_style = "slant",
    diagnostics = "nvim_lsp",
    show_buffer_icon = true,
    show_buffer_close_icon = true,
    diagnostics_indicator = function(count, level, diagnostics_dict)
      local icon = level:match("error") and " " or " "
      return " " .. icon .. count
    end
  }
}
EOF



"
"
" DELIMIATE
"


let g:delimitMate_autoclose = 1
let g:delimitMate_matchpairs = "(:),[:],{:},<:>"
let g:delimitMate_jump_expansion = 1
let g:delimitMate_expand_space = 1
let g:delimitMate_expand_cr = 2
let g:delimitMate_expand_inside_quotes = 1





" lualine
"
let g:use_lualine = 1
if g:use_lualine == 1
lua <<EOF
-- stylua: ignore
local colors = {
  blue   = '#80a0ff',
  cyan   = '#79dac8',
  black  = '#262626',
  white  = '#c6c6c6',
  red    = '#ff5189',
  violet = '#d183e8',
  grey   = '#303030',
}

local bubbles_theme = {
  normal = {
    a = { fg = colors.black, bg = colors.violet },
    b = { fg = colors.white, bg = colors.grey },
    c = { fg = colors.black, bg = colors.black },
  },

  insert = { a = { fg = colors.black, bg = colors.blue } },
  visual = { a = { fg = colors.black, bg = colors.cyan } },
  replace = { a = { fg = colors.black, bg = colors.red } },

  inactive = {
    a = { fg = colors.white, bg = colors.black },
    b = { fg = colors.white, bg = colors.black },
    c = { fg = colors.black, bg = colors.black },
  },
}

require('lualine').setup {
  options = {
    theme = bubbles_theme,
    component_separators = '|',
    section_separators = { left = '', right = '' },
  },
  sections = {
    lualine_a = {
      { 'mode', separator = { left = '' }, right_padding = 2 },
    },
    lualine_b = { 'filename', 'branch' },
    lualine_c = { 'fileformat' },
    lualine_x = {},
    lualine_y = { 'filetype', 'progress', 'diff' },
    lualine_z = {
      { 'location', separator = { right = '' }, left_padding = 2 },
    },
  },
  inactive_sections = {
    lualine_a = { 'filename' },
    lualine_b = {},
    lualine_c = {},
    lualine_x = {},
    lualine_y = {},
    lualine_z = { 'location' },
  },
  tabline = {},
  extensions = {},
}
EOF

endif

" TREESITTER
lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "all", -- one of "all", "maintained" (parsers with maintainers), or a list of languages
  highlight = {
    enable = true,              -- false will disable the whole extension
  },
}
EOF



" FZF

""" COMPAT
command Rg FzfLua live_grep
command Rgr FzfLua live_grep_resume
command Files FzfLua files
command History FzfLua oldfiles
command Buffers FzfLua buffers

nnoremap <C-p> :FzfLua git_files <CR>
inoremap <C-p> <ESC>:FzfLua git_files <CR>



nnoremap <C-x> :FzfLua buffers <CR>
inoremap <C-x> <ESC>:FzfLua buffers <CR>

nnoremap <Leader>r :FzfLua resume <CR>
inoremap <Leader>r <ESC>:FzfLua resume <CR>


nnoremap <C-o> :Rgr <CR>
inoremap <C-o> <ESC>:Rgr <CR>

lua <<EOF
 local actions = require'fzf-lua.actions'
 require 'fzf-lua'.setup({'default',
   actions = {
     files = {
       -- instead of the default action 'actions.file_edit_or_qf'
       -- it's important to define all other actions here as this
       -- table does not get merged with the global defaults
       ["default"]       = actions.file_edit,
       ["ctrl-s"]        = actions.file_split,
       ["ctrl-v"]        = actions.file_vsplit,
       ["ctrl-t"]        = actions.file_tabedit,
       ["ctrl-q"]         = actions.file_sel_to_qf,
     },
   },
 })
EOF


let $FZF_DEFAULT_COMMAND = 'rg --files  --hidden --ignore-vcs'
let g:fzf_buffers_jump = 1
let g:fzf_action = {
  \ 'ctrl-t': 'tab drop',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit'}



let g:float_preview#docked = 0



" PHP LSP inserts double $$
autocmd FileType php setlocal iskeyword+=$

let b:PHP_default_indenting = 1





" DIAG
lua << EOF
vim.o.updatetime = 1000
vim.cmd [[autocmd CursorHold,CursorHoldI * lua vim.diagnostic.open_float(nil, {focus=false})]]

vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
  vim.lsp.diagnostic.on_publish_diagnostics, {

  float = {
    source = "always",  -- Or "if_many"
  },
    virtual_text = false,
    signs = false,
    update_in_insert = false,
    underline = false,
  }
)

vim.fn.sign_define("DiagnosticSignError",
    {text = "",  texthl = 'DiagnosticSignError'})
vim.fn.sign_define("DiagnosticSignWarning",
    {text = "", texthl= 'DiagnosticSignWarning' })
vim.fn.sign_define("DiagnosticSignInformation",
    {text = "", texthl= 'DiagnosticSignInformation'})
vim.fn.sign_define("DiagnosticSignHint",
    {text = "", texthl= 'DiagnosticSignHint'  })

  require("trouble").setup {
    -- your configuration comes here
    -- or leave it empty to use the default settings
    -- refer to the configuration section below
    use_diagnostic_signs = true
  }
EOF


" KEY MAPS
"
map \ :
let mapleader = ','

" Move line up down
" M == OPITION/ALT

nnoremap <silent> <M-Up>    :<C-U>exec "exec 'norm m`' \| move -" . (1+v:count1)<CR>``
nnoremap <silent> <M-Down>  :<C-U>exec "exec 'norm m`' \| move +" . (0+v:count1)<CR>``

inoremap <silent> <M-Up>    <C-O>m`<C-O>:move -2<CR><C-O>``
inoremap <silent> <M-Down>  <C-O>m`<C-O>:move +1<CR><C-O>``

vnoremap <silent> <M-Up>    :<C-U>exec "'<,'>move '<-" . (1+v:count1)<CR>gv
vnoremap <silent> <M-Down>  :<C-U>exec "'<,'>move '>+" . (0+v:count1)<CR>gv



" Close All Buffers
noremap <leader>bd :%bd\|e#\|bd#<cr>\|'"


""" SHOW NETRW 
let g:netrw_browse_split=4
nnoremap <Leader>pv :wincmd v<bar> :Ex <bar> :vertical resize 30<CR>

"""""""YANK TO SSH CLIPBOARD 

let g:oscyank_term = 'default'
vnoremap Y :OSCYankVisual<CR>
nnoremap Y :OSCYankVisual<CR>

inoremap <silent> <F24> <C-\><C-O>:silent doautocmd FocusLost %<CR>
inoremap <silent> <F25> <C-\><C-O>:silent doautocmd FocusGained %<CR>

nnoremap <C-x> :let @0 = expand('%')<CR>:OSCYankRegister 0<CR>


" Apple Keyboard Pasting with OPTION+v 
imap <C-v> <C-R>+
cmap <C-v> <C-R>+



noremap  <C-S> :w<CR>
vnoremap <C-S> <C-C>:w<CR>
inoremap <C-S> <Esc>:w<CR>


if maparg('<C-L>', 'n') ==# ''
  nnoremap <silent> <C-L> :nohlsearch<CR><C-L>
endif


"
" Basic shortcuts definitions
"  most in visual mode / selection (v or ⇧ v)
"

" indent / deindent after selecting the text with (⇧ v), (.) to repeat.
vnoremap <Tab> >
vnoremap <S-Tab> <
" Text wrap simpler, then type the open tag or ',"
vmap <C-w> S

nnoremap <C-z>  :undo<CR>
inoremap <C-z>  <Esc>:undo<CR>
nnoremap <C-y>  :redo<CR>
inoremap <C-y>  <Esc>:redo<CR>








set synmaxcol=240

" OPTION+P / CTRL+P

let g:fzf_preview_window = ['down:40%']




" OPTION + LEFT/RIGHT - navigate TABS
nnoremap <C-Left>  :BufferLineCyclePrev<CR>
inoremap <C-Left>  <Esc>:BufferLineCyclePrev<CR>i
nnoremap <C-Right>  :BufferLineCycleNext<CR>
inoremap <C-Right>  <Esc>:BufferLineCycleNext<CR>i





hi Visual		 guibg=#303731 gui=none ctermfg=15 ctermbg=67
hi VisualNOS    guibg=#303731 gui=none ctermfg=15 ctermbg=67
hi Error  gui=none



" this machine config
if filereadable(expand("~/.vimrc.local"))
  source ~/.vimrc.local
endif

set laststatus=3
highlight WinSeperator guibg=None
